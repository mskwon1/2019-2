## Histogram

- 명암 영상에서 히스토그램 계산

  - 입력 : 명암 영상 $f(j,i)$, $0\le j\le M-1, 0\le j\le N-1$

  - 출력 : 히스토그램 $h(l)$과 정규 히스토그램 $\hat{h}(l), 0\le l\le L-1$

  - Pseudocode

    ~~~pseudocode
    for (l = 0 to L-1) 
    	h(l) = 0; 			// 초기화
    for (j = 0 to M-1)
    	for (i = 0 to N-1) 	// f의 화소(j,i) 각각에 대해
    		h(f(j,i))++; 	// 그곳 명암값에 해당하는 히스토그램 칸을 1만큼 증가
    
    for (l = 0 to L-1) 
    	(hat)h(l) = h(l) / (M * N) // 정규화
    ~~~

  - Python

    ~~~python
    import numpy as np
    import matplotlib.pyplot as plt
    
    def histogram(img):
        bins = np.zeros(256, np.int32) // 초기화
        
        height, width = img.shape // M, N값 받아옴
        
        for i in range(height):
            for j in range(width):
                bins[img[i][j]] += 1 // 그 곳 명암값에 해당하는 히스토그램 칸 1 증가
        
        bins = bins/(width*height)	// 히스토그램 정규화
        
        return bins
    
    # 그레이 스케일로 read
    img = cv2.imread('barbara.jpg',0)
    
    bins = histogram(img)
    
    plt.plot(bins)
    plt.xlim([0,256])
    plt.show()
    ~~~

  - Python - Opencv calcHist 함수 활용

    ~~~python
    import cv2
    # images(uint8 또는 float32 타입의 이미지 - 대괄호안에), channels(채널 인덱스), 
    # 	mask(전체 이미지일시 None), histSize(계산할 막대 개수), ranges(계산 범위)
    # 채널인덱스 : 그레이스케일 => 0, RGB : 0(R), 1(G), 2(B)
    hist = cv2.calcHist([img],[0],None,[256],[0,256]) # 그냥 히스토그램
    
    height, width = img.shape
    hist = hist / (width*height) # 정규화
    ~~~

- 칼라 이미지 히스토그램

  ~~~python
  import cv2
  color_img = cv2.imread('barbara.jpg')
  # cvtColor : BGR 이미지를 RGB로 바꿔줌
  RGB_img = cv2.cvtColor(color_img, cv2.COLOR_BGR2RGB)
  
  # 각 채널별로 histogram 추출
  R_bins = histogram(RGB_img[:,:,0])
  G_bins = histogram(RGB_img[:,:,1])
  B_bins = histogram(RGB_img[:,:,2])
  ~~~

- Histogram - 10 bins

  ~~~python
  # 10레벨 영상으로 표현하기
  def histogram_10bins(img):
      bins = np.zeros(10, np.int32)
      
      height, width = img.shape
      
      for i in range(0, height):
          for j in range(0, width):
              bins[int(img[i][j]/26)] += 1	# int() 함수 써줘야함
      
      return bins
  
  color_img = cv2.imread('barbara.jpg')
  RGB_img = cv2.cvtColor(color_img, cv2.COLOR_BGR2RGB)
  
  R_bins = histogram_10bins(RGB_img[:,:,0])
  G_bins = histogram_10bins(RGB_img[:,:,1])
  B_bins = histogram_10bins(RGB_img[:,:,2])
  
  # 0 ~ len(R_bins) 값을 1 간격을 두고 각각 저장
  x = np.arange(len(R_bins))
  width = 0.2
  # 시작위치, 데이터, 차지하는 width, 색깔
  plt.bar(x - width, R_bins, width, color='r')
  plt.bar(x, G_bins, width, color='g')
  plt.bar(x + width, G_bins, width, color='b')
  
  plt.show()
  ~~~

- 히스토그램 평활화
  $$
  l_{out} = T(l_{in}) = round(c(l_{in}) *(L-1))
  $$

  - 이 때, $c(l_{in}) = \sum^{l_{in}}_{l=0}\hat{h}(l)$

  ~~~python
  import copy
  import cv2
  import numpy as np
  
  def equalizeHist(img):
      new_img = copy.deepcopy(img)
      height, width = new_img.shape
      
      hist = cv2.calcHist([img],[0],None,[256],[0,256]) # 히스토그램 
      hist = hist/(height*width)	# 정규화
      
      # 누적 히스토그램 c
      c = np.cumsum(hist)
      
      for i in range(height):
          for j in range(width):
              new_img[i][j] = round(c[new_img[i][j]] * (255))
      
      return new_img
  ~~~
  - opencv 활용

    ~~~python
    img = cv2.imread('barbara.jpg',0)
    # cv2.equalizeHist(이미지)
    equalized_img = cv2.equalizeHist(img)
    
    plt.imshow(equalized_img, cmap = 'gray')
    
    plt.show()
    ~~~

- 히스토그램 Stretching

  ~~~python
  img = cv2.imread('barbara.jpg', 0)
  hist = cv2.calcHist([img],[0],None,[256],[0,256])
  
  stretched_img = (img - hist.min())/(hist.max()-hist.min())*255
  ~~~

- 임계값 설정

  ~~~python
  img = cv2.imread('barbara.jpg', 0)
  
  # histogram and CDF
  hist = cv2.calcHist([img], [0], None, [256], [0,256])
  hist_norm = hist.ravel() / hist.max()
  CDF = hist_norm.cumsum()
  
  # initialization
  bins = np.arange(256) # 0 ~ 255
  fn_min = np.inf
  thresh = -1
  
  # Otsu algorithm operation
  for i in range(1, 256):
      # hsplit : 인덱스 i를 기준으로 배열을 분할
      p1, p2 = np.hsplit(hist_norm, [i]) # probabilities
      q1, q2 = CDF[i], CDF[255]-CDF[i] # cum sum of classes
      
      if q1 == 0:
          q1 = 0.00000001
      if q2 == 0:
          q2 = 0.00000001
      b1, b2 = np.hsplit(bins, [i]) # weights
      
      # finding means and variances
      m1, m2 = np.sum(p1*b1)/q1, np.sum(p2*b2)/q2
      v1, v2 = np.sum(((b1-m1)**2)*p1)/q1, np.sum(((b2-m2)**2)*p2)/q2
      
      # calculates the minimization function
      fn = v1 * q1 + v2 * q2
      if fn < fn_min:
          fn_min = fn
          thresh = i
          
  # find otsu's threshold value with OpenCV function
  # src(이미지 소스), thresh(임계값), maxval(임계값 넘었을 때 적용할 value), type
  # type : cv2.THRESH_BINARY, THRESH_BINARY_INV, THRESH_TRUNC, THRESH_TOZERO
  #			THRESH_TOZERO_INV, OTSU를 적용하기 위해 THRES_BINARY + THRESH_OTSU
  ret, otsu = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY+cv2.THRESH_OTSU)
  print("thresh: {} ret : {}".format(thresh,ret))
  
  binary_img = np.zeros((img.shape[1], img.shape[0]), np.uint8)
  for i in range(0, img.shape[1]):
      for j in range(0, img.shape[0]):
          if img[i][j] < thresh:
              binary_img[i][j] = 0
          else:
              binary_img[i][j] = 255
  
  plt.figure(figsize = (14,7))
  
  plt.subplot(121)
  plt.imshow(otsu, cmap = 'gray')
  
  plt.subplot(122)
  plt.imshow(binary_img, cmap = 'gray')
  
  plt.show()
  ~~~

  

